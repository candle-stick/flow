# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_graph.ipynb (unless otherwise specified).

__all__ = ['render', 'load', 'build_workflow', 'build_graph', 'load_definition', 'load_configuration',
           'workflow_definition', 'workflow_configuration', 'build', 'workflow', 'workflow_graph', 'templater',
           'render_scaffold', 'scaffold', 'rendered_scaffold', 'render_operator', 'rendered_tasks', 'dag_definition',
           'subworkflows', 'subworkflow_graphs', 'render_subtask', 'render_subtasks']

# Cell
from dataclasses import dataclass, asdict
from functools import partial
from typing import Any, List, Tuple, Iterator, Optional, Dict
from yaml import safe_load
from networkx import (
    DiGraph,
    compose,
    is_directed_acyclic_graph,
    relabel_nodes,
    topological_sort,
    descendants,
    number_of_nodes,
)
from ..domain.model import Task, Config, WorkflowDefinition, Workflow
from ..adapters.templater import *

# Cell
def render(templater: Templater, template, task: dict) -> str:
    return templater.render(template = template, content = task)

# Cell
def load(read, build, path: str):
    with open(path, 'r') as f:
        data = read(f)
    return build(**data)


# Cell
def build_workflow(builder, configuration, name, tasks) -> "Workflow":
    """Build workflows from configuration and definition tasks/subtasks

    Parameters
    ----------
    builder
        Workflow class with `build` method
    configuration
        Workflow configuration
    name
        Workflow name
    tasks
        Workflow tasks

    Returns
    -------
    Workflow
        Workflow object with list of Tasks used to generate graph
    """
    return builder(name, configuration.task_types).build(tasks)

# Cell
def build_graph(workflow: Workflow) -> DiGraph:
    # Add all tasks to a map of string -> task
    task_dict = {task.name: task for task in workflow.tasks}
    task_names = task_dict.keys()

    # DAG of the workflow in its raw/un-optimized state
    input_graph = DiGraph()

    # Add all dependencies as edges
    dependencies = [
        (task_dict[dependency], task)
        for task in workflow.tasks
        for dependency in task.dependencies
    ]
    input_graph.add_edges_from(dependencies)

    # Add all the tasks as vertices.
    input_graph.add_nodes_from(workflow.tasks)

    # Make sure all dependencies have an associated task
    dep_tasks = set(
        [
            dependency
            for task in workflow.tasks
            for dependency in task.dependencies
        ]
    )
    if not dep_tasks.issubset(task_names):
        dep = dep_tasks - task_names
        raise WorkflowGraphError(f"Missing task for dependencies: {dep}")

    return input_graph


# Cell
# Load workflow definition and configuration
load_definition = partial(load, safe_load, WorkflowDefinition.build)
load_configuration = partial(load, safe_load, Config.build)

workflow_definition = load_definition('../temp/workflow.yaml')
workflow_configuration = load_configuration('../temp/config.yaml')

# Build workflow object and derive graph
build = partial(build_workflow,
                Workflow,
                workflow_configuration)

workflow = build(workflow_definition.name, workflow_definition.tasks)

workflow_graph = build_graph(workflow)

# Render Scaffold from workflow definition
templater = JinjaTemplater()

render_scaffold = partial(render, templater, 'scaffold.txt')
# import = set( all imports from workflow )
scaffold = {"imports": {},
            "default_args": workflow_definition.default_args,
            "dag_args": workflow_definition.dag_args}

rendered_scaffold = render_scaffold(scaffold)

# Render operator from workflow graph
render_operator = partial(render, templater, 'operator.txt')
rendered_tasks = [render_operator(task.todict())
                  for task in topological_sort(workflow_graph)]

# Combine Scaffold, Operator and SubDAGs
dag_definition = '\n'.join([rendered_scaffold, '\n']+rendered_tasks)


# Build subworkflows and derives graph
subworkflows = {name : build(name, subtask)
                for (name, subtask)
                in workflow_definition.subtasks.items()}

subworkflow_graphs = {name : build_graph(subworkflow)
                      for (name, subworkflow)
                      in subworkflows.items()}

# Render SubDags from subworkflow graph
render_subtask = partial(render, templater, 'subtask.txt')
render_subtasks = {name : render_subtask(subtask.todict())
                   for (name, subworkflow_graph) in subworkflow_graphs.items()
                   for subtask in topological_sort(subworkflow_graph)}